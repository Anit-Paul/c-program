volatile — Intermediate Explanation

The volatile keyword tells the compiler that the value of a variable can change at any time outside the program’s normal flow.
Therefore, the compiler must not optimize away reads or writes to that variable and must always access it directly from memory.

This is necessary in situations where the variable may be modified by hardware, interrupt service routines, or another execution context.
Without volatile, the compiler may cache the value in a register or remove repeated accesses, leading to incorrect behavior.

volatile ensures visibility of changes, but it does not provide atomicity, synchronization, or thread safety.
It only controls compiler optimizations, not CPU-level reordering or mutual exclusion.

Simple example
volatile int flag = 0;

while (flag == 0) {
    // wait
}


Here, volatile forces the compiler to re-read flag from memory every time.


inline — Intermediate Explanation

The inline keyword is a request to the compiler to replace a function call with the function’s body at the call site.
By doing this, the overhead of function calls (stack setup, jumps, returns) can be avoided, which may improve performance for small, frequently called functions.

inline is not a command—the compiler may ignore it if inlining is not beneficial (e.g., the function is large or recursive).
Inlining can also enable further optimizations like constant folding and dead-code elimination.

Using inline does not change program behavior, only how the compiler generates code.
Overusing inline can increase binary size, which may negatively impact performance.

Simple example
inline int max(int a, int b) {
    return (a > b) ? a : b;
}


The compiler may replace:

x = max(3, 5);


with:

x = (3 > 5) ? 3 : 5;

Common pattern (static inline)
static inline int square(int x) {
    return x * x;
}


Used heavily in headers to avoid multiple-definition issues.